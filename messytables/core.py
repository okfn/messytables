from collections import Mapping
try:
    # python 2.7:
    from collections import OrderedDict
except ImportError:
    from ordereddict import OrderedDict  # noqa


from six import text_type, string_types
from typecast import String

from messytables.error import TableError, NoSuchPropertyError


class CoreProperties(Mapping):
    KEYS = []

    def __getitem__(self, key):
        if key in self.KEYS:
            return getattr(self, 'get_' + key)()
        else:
            raise NoSuchPropertyError("%r" % key)

    def __iter__(self):
        return self.KEYS.__iter__()

    def __len__(self):
        return len(self.KEYS)


class Cell(object):
    """A cell is the basic value type.

    It always has a ``value`` (that may be ``None`` and may optionally
    also have a type and column name associated with it. If no ``type``
    is set, the String type is set but no type conversion is set.
    """

    def __init__(self, value, column=None, type=None):
        if type is None:
            type = String()
        self.value = value
        self.column = column
        self.column_autogenerated = False
        self.type = type

    def __repr__(self):
        if self.column is not None:
            return "<Cell(%r=%r:%r>" % (self.column,
                                        self.type, self.value)
        return "<Cell(%r:%r>" % (self.type, self.value)

    @property
    def empty(self):
        """Stringify the value and check that it has a length."""
        if self.value is None:
            return True
        value = self.value
        if not isinstance(value, string_types):
            value = text_type(value)
        if len(value.strip()):
            return False
        return True

    @property
    def properties(self):
        """Source-specific information. Only a placeholder here."""
        return CoreProperties()

    @property
    def topleft(self):
        """Non-spanning cells are the top left.

        This is used for example in HTML generation where the top left
        cell is the only one which is written into the output representation.
        In absense of other knowledge, we assume that all cells are top left.
        """
        # This seems oddly over-specific, can we solve it otherwise?
        return True


class TableSet(object):
    """A table set bundles multiple tabular objects.

    This might include relational databases and workbooks used in spreadsheet
    software (Excel, LibreOffice).

    For each format, we derive from this abstract base class, providing a
    constructor that takes a file object and tables() that returns each table.
    This means you can stream a table set directly off a web site or some
    similar source.

    On any fatal errors, it should raise messytables.ReadError
    """

    def __init__(self, fileobj):
        """Store the fileobj, and perhaps all or part of the file."""
        pass

    @property
    def tables(self):
        """Get a listing of ``RowSets``."""
        if getattr(self, "_tables", None) is None:
            self._tables = self.make_tables()
        return self._tables

    def make_tables(self):
        raise NotImplementedError("make_tables() not implemented on {0}"
                                  .format(type(self)))

    def __getitem__(self, name):
        """Return a RowSet based on the name given."""
        matching = [table for table in self.tables if table.name == name]
        if not matching:
            raise TableError("No table called %r" % name)
        elif len(matching) > 1:
            raise TableError("Multiple tables match %r" % name)
        return matching[0]

    @classmethod
    def from_fileobj(cls, fileobj, *args, **kwargs):
        """Deprecated, only for compatibility reasons."""
        return cls(fileobj, *args, **kwargs)


class RowSet(object):
    """A single table, which allows iterating over individual rows.

    A row set (aka: table) is a simple wrapper for an iterator of rows
    (which in turn is a list of ``Cell`` objects). The main table iterable
    can only be traversed once, so on order to allow analytics like type and
    header guessing on the data, a sample of ``window`` rows is read, cached,
    and made available.

    On any fatal errors, it should raise messytables.ReadError
    """

    def __init__(self, typed=False):
        self.typed = typed
        self._processors = []
        self._types = None

    def set_types(self, types):
        self.typed = True
        self._types = types

    def get_types(self):
        return self._types

    types = property(get_types, set_types)

    def register_processor(self, processor):
        """Register a stream processor to be used on each row.

        A processor is a function called with the ``RowSet`` as its first
        argument and the row to be processed as the second argument.
        """
        self._processors.append(processor)

    def __iter__(self, sample=False):
        """Apply processors to the row data."""
        for row in self.raw(sample=sample):
            for processor in self._processors:
                row = processor(self, row)
                if row is None:
                    break
            if row is not None:
                yield row

        # this is a bit dirty but required for the offset processor:
        self._offset = 0

    @property
    def sample(self):
        return self.__iter__(sample=True)

    def dicts(self, sample=False):
        """Return the table data as an iterator of ordered dictionaries.

        This is less specific than the cell format returned by the generic
        iterator but only gives a subset of the information.
        """
        generator = self.sample if sample else self
        for row in generator:
            yield OrderedDict([(c.column, c.value) for c in row])

    def __repr__(self):
        return "RowSet(%r)" % self.name
